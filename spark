#!/usr/bin/env bash
# This web-based sparkline generator that was a bit of inspiration for spark:
#   https://datacollective.org/sparkblocks

set -o noglob

: ${SPARK_TICKS='â– â–‚ â–ƒ â–„ â–… â–† â–‡ â–ˆ'}
originalSparkEmpty="$SPARK_EMPTY"
: ${SPARK_EMPTY= }
: ${SPARK_EMPTY_DATA= }
originalSparkZero="$SPARK_ZERO"
: ${SPARK_ZERO=_}
: ${SPARK_BOX=â–ˆ}
: ${SPARK_UNKNOWN=Ã—}
: ${SPARK_UNKNOWN_DATA=x}
: ${SPARK_UNDERFLOW=â­³}
: ${SPARK_OVERFLOW=â­±}

# Generates sparklines.
#
# $1 - The data we'd like to graph.
_echo()
{
  if [ "X$1" = "X-n" ]; then
    shift
    printf "%s" "$*"
  else
    printf "%s\n" "$*"
  fi
}

scaleNumber()
{
  printf '%d\n' "${1:?}"
}

spark()
{
  if [ -n "$scaleFunction" ]; then
    coproc BC { bc --mathlib; } # Start a coproc to scale individual numbers; this is much more efficient than starting a new process for each number.
    scaleNumber()
    {
        printf "${scaleFunction}\n" "${1:?}" >&"${BC[1]}"
        read -ru "${BC[0]}" scaledNumber
        printf '%d\n' "${scaledNumber%.*}"
    }
  fi

  local item n numbers=

  # find min/max values
  local min="$(scaleNumber "${fixedMin:-0xffffffff}")" max="$(scaleNumber "${fixedMax:-0}")"

  [ -z "$fixedMin" -o -z "$fixedMax" ] && for item
  do
    # on Linux (or with bash4) we could use `printf %.0f $n` here to
    # round the number but that doesn't work on OS X (bash3) nor does
    # `awk '{printf "%.0f",$1}' <<< $n` work, so just cut it off
    n=${item%.*}
    [[ "$n" =~ ^[[:digit:]]+$ ]] || continue
    [ -z "$fixedMin" ] && (( n < min )) && min="$(scaleNumber "$n")"
    [ -z "$fixedMax" ] && (( n > max )) && max="$(scaleNumber "$n")"
  done

  # Use a middle tick to render constant data.
  if (( min == max )); then
    middleTickNr=$((${#ticks[@]} / 2))
    ticks=("${ticks[@]:$middleTickNr:$((middleTickNr+1))}")
  fi

  local f=$(( (($max-$min)<<8)/(${#ticks[@]}-1) ))
  (( f < 1 )) && f=1

  for item
  do
    n=${item%.*}
    if [[ "$n" =~ ^[[:digit:]]+$ ]]; then
      n="$(scaleNumber "$n")"
      if [ $n -lt $min ]; then
        _echo -n "$SPARK_UNDERFLOW"
      elif [ $n -gt $max ]; then
        _echo -n "$SPARK_OVERFLOW"
      elif [[ "$item" =~ ^0+(\.0+)?$ ]]; then
        _echo -n "$SPARK_ZERO"
      else
        _echo -n "${ticks[$(( ((($n-$min)<<8)/$f) ))]}"
      fi
    elif [ -n "$SPARK_UNKNOWN_DATA" ] && [ "$item" = "$SPARK_UNKNOWN_DATA" ]; then
        _echo -n "$SPARK_UNKNOWN"
    elif [ -n "$SPARK_EMPTY_DATA" ] && [ "$item" = "$SPARK_EMPTY_DATA" ]; then
      _echo -n "$SPARK_EMPTY"
    else
      _echo -n "$item"
    fi
  done
  _echo
}

abortInvalidTick()
{
  printf >&2 'ERROR: Invalid tick name: %s\n' "${2:?}"
  echo >&2
  printUsage "${1:?}" >&2
  exit 2
}

greyscale()
{
  typeset -a coloredTicks=()
  local tick; for tick in "${ticks[@]}"
  do
    for ((i = 255; i >= 232; i--))
    do
      coloredTicks+=("[38;5;${i}m${tick}[0m")
    done
    coloredTicks+=("$tick")
  done
  ticks=("${coloredTicks[@]}")
}

rainbow()
{
  local isSingleTick; [ ${#ticks[@]} -eq 1 ] && isSingleTick=t
  typeset -a coloredTicks=()
  local tick; for tick in "${ticks[@]}"
  do
    for i in 55 20 21 26 68 67 72 79 78 114 113 118 148 185 226 220 202 196 160 198 163 127
    do
      coloredTicks+=("[38;5;${i}m${tick}[0m")
    done
  done
  ticks=("${coloredTicks[@]}")
}

RGBrainbow()
{
  typeset -a coloredTicks=()
  local tick; for tick in "${ticks[@]}"
  do
    for ((i = 76; i >= 0; i--))
    do
      r=$((255 - (i * 255 / 76)))
      g=$((i * 510 / 76))
      b=$((i * 255 / 76))
      ((g > 255)) && g=$((510 - g))
      coloredTicks+=("[38;2;${r};${g};${b}m${tick}[0m")
    done
  done
  ticks=("${coloredTicks[@]}")
}

green()
{
  local isSingleTick; [ ${#ticks[@]} -eq 1 ] && isSingleTick=t
  typeset -a coloredTicks=()
  local tick; for tick in "${ticks[@]}"
  do
    for i in ${isSingleTick:+194} 157 114 71 28 22  # Only use the lightest color when there's a single tick.
    do
      coloredTicks+=("[38;5;${i}m${tick}[0m")
    done
    coloredTicks+=("$tick")
  done
  ticks=("${coloredTicks[@]}")
}



[ "$BASH_SOURCE" != "$0" ] && return # Skip command-line argument parsing when sourced.

# Prints the help text for spark.
printUsage()
{
  local spark="$(basename "$1")"
  cat <<EOF

  USAGE:
    $spark [-h|--help] [--min n] [--max n] [--scale ld|ln|log10] [--flip|--as sized-boxes|sized-fullwidth-boxes|color-fullwidth-boxes|shaded-boxes|double-shaded-squares|(greyscale|green|[RGB]rainbow)-(boxes|center-boxes|double-squares|double-center-squares|sized-boxes)] VALUE,...
    cat FILE [...] | $spark [...] [-]

    Generates sparklines for a set of data; it takes a comma-separated or
    space-separated list of data and then prints a sparkline out of it.

    Separate whitespace arguments are taken over to the output.
    Completely empty lines in the input are rendered as spaces.
    Unknown data can be marked with x.

  EXAMPLES:
    $spark 0 30 55 80 ' ' 80 55 30 0 $'\n' 0 0 30 30 0 0 55 0 0
    â–â–ƒâ–…â–ˆ â–ˆâ–…â–ƒâ–
    â–â–â–ƒâ–ƒâ–â–â–…â–â–
    $spark 1 5 22 x 53
    â–â–â–ƒ${SPARK_UNKNOWN}â–ˆ
    $spark 0,30,55,80,33,150
    â–â–‚â–ƒâ–„â–‚â–ˆ
    echo 9 13 5 17 1 | $spark
    â–„â–†â–‚â–ˆâ–
EOF
}

typeset -a ticks=($SPARK_TICKS)
fixedMin=
fixedMax=
while [ $# -ne 0 ]
do
  case "$1" in
    --help|-h|-\?)  shift; printUsage "$0"; exit 0;;
    --min)          shift; fixedMin="$1"; shift;;
    --max)          shift; fixedMax="$1"; shift;;
    --scale)        shift
                    case "$1" in
                      ln)     shift; scaleFunction='l(%d)';;
                      ld)     shift; scaleFunction='l(%d)/l(2)';;
                      log10)  shift; scaleFunction='l(%d)/l(10)';;
                      *)      printf >&2 'ERROR: Invalid scale: %s\n' "$1"
                              echo >&2
                              printUsage >&2 "$0"
                              exit 2
                      esac
                    ;;
    --flip)         shift; ticks=(â–‡ â–† â–… â–„ â–ƒ â–‚ â–); ticks=("${ticks[@]/#/[07m}"); ticks=("${ticks[@]/%/[0m}"); ticks+=(â–ˆ);;
    --as)           shift
                    colorizer=
                    scheme="$1"; shift
                    case "$scheme" in
                      gr[ae]yscale-*)
                        colorizer=greyscale
                        scheme="${scheme#*-}"
                        ;;
                      green-*)
                        colorizer=green
                        scheme="${scheme#*-}"
                        ;;
                      rainbow-*)
                        colorizer=rainbow
                        scheme="${scheme#*-}"
                        ;;
                      RGBrainbow-*)
                        colorizer=RGBrainbow
                        scheme="${scheme#*-}"
                        ;;
                    esac

                    case "$scheme" in
                      boxes)
                        [ -n "$colorizer" ] || abortInvalidTick "$0" "$scheme"
                        ticks=("$SPARK_BOX")
                        ;;
                      center-boxes)
                        [ -n "$colorizer" ] || abortInvalidTick "$0" "$scheme"
                        ticks=('âˆŽ')
                        ;;
                      double-squares)
                        [ -n "$colorizer" ] || abortInvalidTick "$0" "$scheme"
                        SPARK_EMPTY="${originalSparkEmpty:-"${SPARK_EMPTY}${SPARK_EMPTY}"}"
                        ticks=('â–ˆâ–ˆ')
                        ;;
                      double-center-squares)
                        [ -n "$colorizer" ] || abortInvalidTick "$0" "$scheme"
                        SPARK_EMPTY="${originalSparkEmpty:-"${SPARK_EMPTY}${SPARK_EMPTY}"}"
                        ticks=('â–â–˜')
                        ;;

                      sized-boxes)
                        ticks=(ðŸžŒ Â· â–ª âˆŽ â–ˆ);;
                      sized-fullwidth-boxes)
                        SPARK_EMPTY="${originalSparkEmpty:-ã€€}"
                        SPARK_ZERO="${originalSparkZero:-ã€€}"
                        ticks=(ãƒ» â—¾ â¬›);;
                      color-fullwidth-boxes)
                        SPARK_EMPTY="${originalSparkEmpty:-â¬œ}"
                        SPARK_ZERO="${originalSparkZero:-â¬›}"
                        ticks=(ðŸŸª ðŸŸ¦ ðŸŸ© ðŸŸ¨ ðŸŸ§ ðŸŸ¥);;

                      shaded-boxes)
                        SPARK_ZERO="${originalSparkZero:- }"
                        ticks=(â–‘ â–’ â–’ â–“ â–ˆ);;
                      double-shaded-squares)
                        SPARK_EMPTY="${originalSparkEmpty:-  }"
                        SPARK_ZERO="${originalSparkZero:-  }"
                        ticks=(â–‘â–‘ â–’â–’ â–’â–’ â–“â–“ â–ˆâ–ˆ);;

                      *)
                        abortInvalidTick "$0" "$scheme";;
                    esac

                    $colorizer
                    ;;
    --)             shift; break;;
    -)              break;;
    -*)             { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
    *)              break;;
  esac
done
# Show help for no arguments if stdin is a terminal
if [ $# -eq 0 -a -t 0 ]; then
  printUsage >&2 "$0"
  exit 2
fi

if [ $# -eq 0 -o "$1" = '-' ]; then
  readarray -t numbers < <(sed -e 's/,/\n/g' -e 't end' -e 's/[[:space:]]/\n/g' -e :end -e 's/^$/ /')
else
  typeset -a numbers=()
  for arg
  do
    if [[ "$arg" =~ , ]]; then
      IFS=, read -r -a newNumbers <<<"${arg//$'\n'/}"
      numbers+=("${newNumbers[@]///$'\n'}")
    else
      numbers+=("$arg")
    fi
  done
fi

spark "${numbers[@]}"
